<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ComicTrackr</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css.css">
    

    
</head>
<body class="bg-gray-50"> <div id="app-container">
        <main class="p-4">
            <div id="message-box" role="alert">
                 <span id="message-box-icon" class="lucide"></span>
                 <span id="message-box-text">Message goes here</span>
            </div>

            <div id="view-collection" class="space-y-4">
                <h1 class="text-2xl font-bold text-gray-900">My Collection</h1>
                <div class="relative">
                    <input type="text" id="search-input" placeholder="Search by title, issue, publisher..." class="w-full p-2 pl-10 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-gray-800">
                    <span class="lucide icon-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></span>
                </div>
                 <div class="flex justify-end space-x-2">
                     <button id="toggle-view-btn" aria-label="Toggle grid/list view" class="p-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500">
                        <span class="lucide icon-layout-grid icon-sm"></span> </button>
                </div>
                <div id="collection-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                    </div>
                <div id="collection-list-list-view" class="space-y-3 hidden">
                    </div>
                 <p id="no-comics-message" class="text-gray-500 col-span-full text-center hidden py-6">Your collection is empty. Add some comics!</p>
                 <div id="loading-spinner" class="loader hidden"></div>
            </div>

            <div id="view-add" class="hidden space-y-4">
                 <button id="back-to-collection-btn" class="mb-4 text-indigo-700 hover:text-indigo-900 flex items-center space-x-1 focus:outline-none focus:ring-2 focus:ring-indigo-500 rounded">
                    <span class="lucide icon-arrow-left icon-sm"></span>
                    <span>Back to Collection</span>
                </button>
                <h1 id="add-edit-title" class="text-2xl font-bold text-gray-900">Add New Comic</h1>
                <form id="comic-form" class="space-y-4 bg-white p-4 rounded-lg shadow" novalidate> <input type="hidden" id="comic-id"> <div>
                        <label for="comic-title" class="block text-sm font-medium text-gray-700">Title <span class="text-red-500">*</span></label>
                        <input type="text" id="comic-title" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                        <p class="text-red-600 text-xs italic mt-1 hidden" data-validation-for="comic-title">Title is required.</p>
                    </div>
                    <div>
                        <label for="comic-issue" class="block text-sm font-medium text-gray-700">Issue # <span class="text-red-500">*</span></label>
                        <input type="text" id="comic-issue" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                         <p class="text-red-600 text-xs italic mt-1 hidden" data-validation-for="comic-issue">Issue number is required.</p>
                    </div>
                    <div>
                        <label for="comic-date" class="block text-sm font-medium text-gray-700">Release Date</label>
                        <input type="date" id="comic-date" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                    </div>
                     <div>
                        <label for="comic-cost" class="block text-sm font-medium text-gray-700">Cost ($)</label>
                        <input type="number" step="0.01" min="0" id="comic-cost" placeholder="e.g., 3.99" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                         <p class="text-red-600 text-xs italic mt-1 hidden" data-validation-for="comic-cost">Please enter a valid positive cost.</p>
                    </div>
                    <div>
                        <label for="comic-artist" class="block text-sm font-medium text-gray-700">Cover Artist</label>
                        <input type="text" id="comic-artist" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                    </div>
                    <div>
                        <label for="comic-publisher" class="block text-sm font-medium text-gray-700">Publisher</label>
                        <input type="text" id="comic-publisher" list="publishers-list" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 text-gray-900">
                         <datalist id="publishers-list">
                            <option value="Marvel Comics">
                            <option value="DC Comics">
                            <option value="Image Comics">
                            <option value="Dark Horse Comics">
                            <option value="IDW Publishing">
                            <option value="Boom! Studios">
                            <option value="Dynamite Entertainment">
                            <option value="Valiant Comics">
                            <option value="Archie Comics">
                            <option value="AfterShock Comics">
                            <option value="Abstract Studio">
                            <option value="Avatar Press">
                            <option value="Oni Press">
                            <option value="Vault Comics">
                            <option value="VIZ Media">
                            <option value="Yen Press">
                            </datalist>
                    </div>
                     <div>
                        <label for="comic-cover-upload" class="block text-sm font-medium text-gray-700">Cover Photo</label>
                         <label for="comic-cover-upload" class="mt-1 inline-flex items-center space-x-2 py-1.5 px-3 rounded-md border border-gray-300 bg-indigo-600 text-white text-sm font-medium shadow-sm hover:bg-indigo-700 cursor-pointer focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500">
                             <span class="lucide icon-camera icon-sm"></span>
                             <span>Upload/Take Photo</span>
                         </label>
                        <input id="comic-cover-upload" type="file" accept="image/*">
                        <img id="cover-preview" src="#" alt="Cover preview" class="mt-2 rounded-md max-h-40 hidden"/>
                        <input type="hidden" id="comic-cover-data"> <p class="text-red-600 text-xs italic mt-1 hidden" data-validation-for="comic-cover-upload">Image file is too large (max 2MB).</p>
                    </div>

                    <button type="submit" class="w-full inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-60 disabled:cursor-not-allowed">
                        <span id="save-btn-text">Save Comic</span>
                        <span id="save-btn-loader" class="inline-loader hidden"></span>
                    </button>
                </form>
            </div>

            <div id="view-detail" class="hidden space-y-4">
                 <button id="back-to-collection-detail-btn" class="mb-4 text-indigo-700 hover:text-indigo-900 flex items-center space-x-1 focus:outline-none focus:ring-2 focus:ring-indigo-500 rounded">
                    <span class="lucide icon-arrow-left icon-sm"></span>
                    <span>Back to Collection</span>
                </button>
                <div id="detail-content" class="bg-white p-4 rounded-lg shadow space-y-3 min-h-[200px]">
                    </div>
                <div class="flex space-x-2">
                    <button id="edit-comic-btn" class="flex-1 inline-flex justify-center py-2 px-4 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                        Edit
                    </button>
                    <button id="delete-comic-btn" class="flex-1 inline-flex justify-center items-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                        <span class="lucide icon-trash-2 mr-2"></span> Delete
                    </button>
                </div>
            </div>

             <div id="view-series" class="hidden space-y-4">
                 <button id="back-to-detail-btn" class="mb-4 text-indigo-700 hover:text-indigo-900 flex items-center space-x-1 focus:outline-none focus:ring-2 focus:ring-indigo-500 rounded">
                    <span class="lucide icon-arrow-left icon-sm"></span>
                    <span id="back-to-detail-comic-info">Back</span> </button>
                <h1 id="series-title" class="text-2xl font-bold text-gray-900">Series Title</h1>
                <div id="series-list" class="space-y-2">
                    <div class="loader"></div> </div>
            </div>

        </main>

        <footer class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-md z-50">
            <nav class="flex justify-around p-2">
                 <button data-view="collection" aria-label="View Collection" class="nav-btn flex flex-col items-center text-indigo-600 p-2 rounded-md w-1/3 hover:bg-gray-100 focus:outline-none focus:bg-gray-100 focus:ring-1 focus:ring-indigo-500">
                    <span class="lucide icon-book-open icon-md"></span>
                    <span class="text-xs font-medium">Collection</span>
                </button>
                <button data-view="add" aria-label="Add Comic" class="nav-btn flex flex-col items-center text-gray-500 hover:text-indigo-600 hover:bg-gray-100 p-2 rounded-md w-1/3 focus:outline-none focus:bg-gray-100 focus:ring-1 focus:ring-indigo-500">
                    <span class="lucide icon-plus-circle icon-md"></span>
                    <span class="text-xs font-medium">Add Comic</span>
                </button>
                 <button id="scan-comic-btn" aria-label="Scan Comic (Simulated)" class="flex flex-col items-center text-gray-500 hover:text-indigo-600 hover:bg-gray-100 p-2 rounded-md w-1/3 focus:outline-none focus:bg-gray-100 focus:ring-1 focus:ring-indigo-500">
                    <span class="lucide icon-camera icon-md"></span>
                    <span class="text-xs font-medium">Scan Comic</span>
                </button>
            </nav>
        </footer>
    </div>

    <script>
        // ========================================================================
        // ComicTrackr - Frontend Application Logic (v.Contrast)
        // ========================================================================

        // --- Constants ---
        const COMICS_STORAGE_KEY = 'comicTrackr_comics_v2';
        const WANTS_STORAGE_KEY = 'comicTrackr_wants_v2';
        const LAYOUT_STORAGE_KEY = 'comicTrackr_layout';
        const PLACEHOLDER_IMAGE = 'https://placehold.co/200x300/e2e8f0/94a3b8?text=No+Cover';
        const MAX_IMAGE_SIZE_BYTES = 2 * 1024 * 1024; // 2MB limit for cover images

        // --- DOM Element References ---
        const appElements = {
            views: {
                collection: document.getElementById('view-collection'),
                add: document.getElementById('view-add'),
                detail: document.getElementById('view-detail'),
                series: document.getElementById('view-series')
            },
            collection: {
                list: document.getElementById('collection-list'),
                listView: document.getElementById('collection-list-list-view'),
                noComicsMessage: document.getElementById('no-comics-message'),
                loadingSpinner: document.getElementById('loading-spinner'),
                searchInput: document.getElementById('search-input'),
                toggleViewBtn: document.getElementById('toggle-view-btn')
            },
            addForm: {
                form: document.getElementById('comic-form'),
                title: document.getElementById('add-edit-title'),
                idInput: document.getElementById('comic-id'),
                titleInput: document.getElementById('comic-title'),
                issueInput: document.getElementById('comic-issue'),
                dateInput: document.getElementById('comic-date'),
                costInput: document.getElementById('comic-cost'),
                artistInput: document.getElementById('comic-artist'),
                publisherInput: document.getElementById('comic-publisher'),
                coverUpload: document.getElementById('comic-cover-upload'),
                coverPreview: document.getElementById('cover-preview'),
                coverDataInput: document.getElementById('comic-cover-data'),
                submitBtn: document.querySelector('#comic-form button[type="submit"]'),
                saveBtnText: document.getElementById('save-btn-text'),
                saveBtnLoader: document.getElementById('save-btn-loader')
            },
            detail: {
                content: document.getElementById('detail-content'),
                editBtn: document.getElementById('edit-comic-btn'),
                deleteBtn: document.getElementById('delete-comic-btn'),
                backBtn: document.getElementById('back-to-collection-detail-btn')
            },
            series: {
                title: document.getElementById('series-title'),
                list: document.getElementById('series-list'),
                backBtn: document.getElementById('back-to-detail-btn'),
                backBtnInfo: document.getElementById('back-to-detail-comic-info')
            },
            navigation: {
                navButtons: document.querySelectorAll('.nav-btn'),
                scanBtn: document.getElementById('scan-comic-btn'),
                backToAddBtn: document.getElementById('back-to-collection-btn')
            },
            ui: {
                messageBox: document.getElementById('message-box'),
                messageBoxIcon: document.getElementById('message-box-icon'),
                messageBoxText: document.getElementById('message-box-text')
            }
        };

        // --- Application State ---
        let state = {
            comics: [],
            wantsList: [],
            currentView: 'collection',
            currentDetailComicId: null,
            currentLayout: 'grid',
            messageTimeoutId: null
        };

        // --- Mock Series Database ---
        const mockSeriesDb = {
            "Amazing Spider-Man": [1, 2, 3, 4, 5, 298, 299, 300, 600, 700, 800, 801],
            "Batman": [1, 2, 3, 404, 405, 406, 407, 608, 609, 610, 1000],
            "Saga": [1, 2, 3, 4, 5, 6, 50, 51, 52, 53, 54],
            "Invincible": [1, 2, 3, 100, 144]
        };

        // ========================================================================
        // Utility Functions
        // ========================================================================

        function showView(viewId) {
            console.log(`Navigating to view: view-${viewId}`);
            state.currentView = viewId;
            Object.values(appElements.views).forEach(view => view.classList.add('hidden'));
            const targetViewElement = appElements.views[viewId];
            if (targetViewElement) {
                targetViewElement.classList.remove('hidden');
                if (viewId === 'add') {
                    setSaveButtonState(true);
                }
            } else {
                console.error("View element not found for ID:", viewId);
                appElements.views.collection.classList.remove('hidden');
                state.currentView = 'collection';
            }
            updateNavButtonsUI();
            window.scrollTo(0, 0);
        }

        function updateNavButtonsUI() {
            appElements.navigation.navButtons.forEach(btn => {
                const view = btn.getAttribute('data-view');
                // Use more robust check for active state
                const isActive = (view === state.currentView);
                 btn.classList.toggle('text-indigo-600', isActive);
                 btn.classList.toggle('text-gray-500', !isActive); // Adjusted inactive color
                 btn.classList.toggle('hover:text-indigo-600', !isActive); // Keep hover effect on inactive
            });
            // Special handling for scan button
            appElements.navigation.scanBtn.classList.remove('text-indigo-600');
            appElements.navigation.scanBtn.classList.add('text-gray-500', 'hover:text-indigo-600');
        }

        function loadData() {
            try {
                const storedComics = localStorage.getItem(COMICS_STORAGE_KEY);
                const storedWants = localStorage.getItem(WANTS_STORAGE_KEY);
                const storedLayout = localStorage.getItem(LAYOUT_STORAGE_KEY);
                state.comics = storedComics ? JSON.parse(storedComics) : [];
                state.wantsList = storedWants ? JSON.parse(storedWants) : [];
                state.currentLayout = storedLayout || 'grid';
                if (!Array.isArray(state.comics)) state.comics = [];
                if (!Array.isArray(state.wantsList)) state.wantsList = [];
                if (!['grid', 'list'].includes(state.currentLayout)) state.currentLayout = 'grid';
                console.log(`Loaded ${state.comics.length} comics, ${state.wantsList.length} wants, layout: ${state.currentLayout}`);
            } catch (error) {
                console.error("Error loading data from localStorage:", error);
                showMessage("Error loading saved data. Starting fresh.", 'error', 5000);
                state.comics = []; state.wantsList = []; state.currentLayout = 'grid';
            }
            updateToggleViewButtonUI();
        }

        function saveData() {
             try {
                localStorage.setItem(COMICS_STORAGE_KEY, JSON.stringify(state.comics));
                localStorage.setItem(WANTS_STORAGE_KEY, JSON.stringify(state.wantsList));
                localStorage.setItem(LAYOUT_STORAGE_KEY, state.currentLayout);
                console.log(`Saved ${state.comics.length} comics, ${state.wantsList.length} wants, layout: ${state.currentLayout}`);
             } catch (error) {
                 console.error("Error saving data to localStorage:", error);
                 if (error.name === 'QuotaExceededError') {
                     showMessage("Error: Storage limit reached. Cannot save changes.", 'error', 8000);
                 } else {
                     showMessage("Error saving data.", 'error', 5000);
                 }
             }
        }

        function showMessage(message, type = 'info', duration = 3500) {
            const { messageBox, messageBoxIcon, messageBoxText } = appElements.ui;
            if (state.messageTimeoutId) clearTimeout(state.messageTimeoutId);
            messageBoxText.textContent = message;
            let iconClass = '';
            switch (type) { case 'success': iconClass = 'icon-check-circle'; break; case 'error': iconClass = 'icon-alert-triangle'; break; }
            messageBoxIcon.className = `lucide ${iconClass}`;
            messageBoxIcon.style.display = iconClass ? 'inline-block' : 'none';
            messageBox.className = ``; // Clear previous classes
            messageBox.classList.add('show', type); // Add show and type class
            state.messageTimeoutId = setTimeout(() => {
                messageBox.classList.remove('show');
                state.messageTimeoutId = null;
                 setTimeout(() => { messageBox.classList.remove(type); }, 500);
            }, duration);
        }

        function generateComicId() { return `comic_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`; }

        function setSaveButtonState(enable) {
             const { submitBtn, saveBtnText, saveBtnLoader } = appElements.addForm;
             if (enable) {
                 submitBtn.disabled = false;
                 submitBtn.classList.remove('opacity-60', 'cursor-not-allowed'); // Adjusted disabled style class
                 saveBtnText.classList.remove('hidden');
                 saveBtnLoader.classList.add('hidden');
             } else {
                 submitBtn.disabled = true;
                 submitBtn.classList.add('opacity-60', 'cursor-not-allowed');
                 saveBtnText.classList.add('hidden');
                 saveBtnLoader.classList.remove('hidden');
             }
        }

        // ========================================================================
        // Rendering Functions
        // ========================================================================

        function renderCollection(filter = '') {
            const { list, listView, loadingSpinner, noComicsMessage } = appElements.collection;
            list.innerHTML = ''; listView.innerHTML = '';
            loadingSpinner.classList.remove('hidden');
            noComicsMessage.classList.add('hidden');
            console.log(`Rendering collection with filter: "${filter}"`);

            requestAnimationFrame(() => {
                setTimeout(() => {
                    try {
                        const lowerCaseFilter = filter.toLowerCase();
                        const filteredComics = state.comics.filter(comic =>
                            comic.title.toLowerCase().includes(lowerCaseFilter) ||
                            comic.issue.toLowerCase().includes(lowerCaseFilter) ||
                            (comic.publisher && comic.publisher.toLowerCase().includes(lowerCaseFilter))
                        ).sort((a, b) => {
                             const titleCompare = a.title.toLowerCase().localeCompare(b.title.toLowerCase());
                             if (titleCompare !== 0) return titleCompare;
                             const issueA = parseFloat(a.issue); const issueB = parseFloat(b.issue);
                             if (!isNaN(issueA) && !isNaN(issueB)) return issueA - issueB;
                             if (!isNaN(issueA)) return -1; if (!isNaN(issueB)) return 1;
                             return a.issue.localeCompare(b.issue);
                         });

                        console.log(`Found ${filteredComics.length} comics matching filter.`);

                        if (filteredComics.length === 0) {
                            noComicsMessage.classList.remove('hidden');
                            noComicsMessage.textContent = filter ? `No comics found matching "${filter}".` : 'Your collection is empty. Add some comics!';
                        } else {
                            noComicsMessage.classList.add('hidden');
                            filteredComics.forEach(comic => {
                                const coverSrc = comic.coverImage || PLACEHOLDER_IMAGE;
                                const readIconHtml = comic.status.read ? '<span class="lucide icon-eye text-green-500 text-xs" title="Read"></span>' : '<span class="lucide icon-eye-off text-gray-400 text-xs" title="Unread"></span>'; // Adjusted unread icon color
                                const readIconHtmlSm = comic.status.read ? '<span class="lucide icon-eye text-green-500 icon-sm" title="Read"></span>' : '<span class="lucide icon-eye-off text-gray-400 icon-sm" title="Unread"></span>'; // Adjusted unread icon color

                                // --- Grid Item ---
                                const gridItem = document.createElement('div');
                                // Adjusted text colors
                                gridItem.className = 'comic-item bg-white rounded-lg shadow overflow-hidden cursor-pointer transform transition hover:scale-105 focus-within:ring-2 focus-within:ring-indigo-500 focus-within:ring-offset-1';
                                gridItem.dataset.id = comic.id;
                                gridItem.setAttribute('tabindex', '0'); gridItem.setAttribute('role', 'button'); gridItem.setAttribute('aria-label', `${comic.title} issue ${comic.issue}`);
                                gridItem.innerHTML = `
                                    <img loading="lazy" src="${coverSrc}" alt="${comic.title} Cover" class="w-full h-48 object-cover" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMAGE}';">
                                    <div class="p-2">
                                        <h3 class="font-semibold text-sm text-gray-800 truncate" title="${comic.title} #${comic.issue}">${comic.title}</h3>
                                        <p class="text-xs text-gray-600">#${comic.issue}</p>
                                        <div class="mt-1 flex justify-end space-x-1">${readIconHtml}</div>
                                    </div>
                                `;
                                gridItem.addEventListener('click', () => handleComicItemClick(comic.id));
                                gridItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleComicItemClick(comic.id); });
                                list.appendChild(gridItem);

                                // --- List Item ---
                                const listItem = document.createElement('div');
                                // Adjusted text colors
                                listItem.className = 'comic-list-item bg-white rounded-lg shadow p-3 flex items-center space-x-3 cursor-pointer hover:bg-gray-50 focus-within:ring-1 focus-within:ring-indigo-500';
                                listItem.dataset.id = comic.id;
                                listItem.setAttribute('tabindex', '0'); listItem.setAttribute('role', 'button'); listItem.setAttribute('aria-label', `${comic.title} issue ${comic.issue}`);
                                listItem.innerHTML = `
                                     <img loading="lazy" src="${coverSrc}" alt="${comic.title} Cover" class="w-12 h-16 object-cover rounded flex-shrink-0" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMAGE}';">
                                     <div class="flex-grow overflow-hidden">
                                         <h3 class="font-semibold text-base text-gray-800 truncate" title="${comic.title} #${comic.issue}">${comic.title} #${comic.issue}</h3>
                                         <p class="text-sm text-gray-500 truncate">${comic.publisher || 'Unknown Publisher'}</p>
                                     </div>
                                     <div class="flex-shrink-0 flex items-center space-x-2">${readIconHtmlSm}</div>
                                `;
                                listItem.addEventListener('click', () => handleComicItemClick(comic.id));
                                listItem.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') handleComicItemClick(comic.id); });
                                listView.appendChild(listItem);
                            });
                        }
                        toggleCollectionViewLayoutUI(state.currentLayout);
                    } catch (error) {
                        console.error("Error rendering collection:", error);
                        noComicsMessage.textContent = 'Error displaying comics.';
                        noComicsMessage.classList.remove('hidden');
                    } finally {
                         loadingSpinner.classList.add('hidden');
                    }
                }, 50);
            });
        }

        function toggleCollectionViewLayoutUI(layout) {
             const { list, listView } = appElements.collection;
             if (layout === 'list') { list.classList.add('hidden'); listView.classList.remove('hidden'); }
             else { list.classList.remove('hidden'); listView.classList.add('hidden'); }
             updateToggleViewButtonUI();
        }

        function updateToggleViewButtonUI() {
             const iconSpan = appElements.collection.toggleViewBtn.querySelector('.lucide');
             if (state.currentLayout === 'list') {
                 iconSpan.className = 'lucide icon-layout-grid icon-sm'; // Set class directly
                 appElements.collection.toggleViewBtn.setAttribute('aria-label', 'Switch to grid view');
             } else {
                 iconSpan.className = 'lucide icon-list icon-sm'; // Set class directly
                 appElements.collection.toggleViewBtn.setAttribute('aria-label', 'Switch to list view');
             }
        }

        function showComicDetail(comicId) {
            const { content: detailContentElement } = appElements.detail;
            detailContentElement.innerHTML = '<div class="loader"></div>';
            showView('detail');

            setTimeout(() => {
                const comic = state.comics.find(c => c.id === comicId);
                if (!comic) { showMessage("Error: Comic not found.", 'error'); showView('collection'); return; }
                console.log("Showing details for comic:", comic);
                state.currentDetailComicId = comicId;

                const coverSrc = comic.coverImage || PLACEHOLDER_IMAGE;
                const costDisplay = comic.cost ? `$${parseFloat(comic.cost).toFixed(2)}` : '';
                const readButtonText = comic.status.read ? 'Mark as Unread' : 'Mark as Read';
                const readButtonIcon = comic.status.read ? 'icon-eye-off' : 'icon-eye';
                const readButtonColor = comic.status.read ? 'bg-yellow-500 hover:bg-yellow-600' : 'bg-green-600 hover:bg-green-700';

                // Adjusted text colors for detail view
                detailContentElement.innerHTML = `
                    <img src="${coverSrc}" alt="${comic.title} Cover" class="w-full max-w-xs mx-auto h-auto object-contain rounded-lg shadow mb-4" onerror="this.onerror=null;this.src='${PLACEHOLDER_IMAGE}';">
                    <h2 class="text-xl font-bold text-gray-900">${comic.title} #${comic.issue}</h2>
                    ${comic.publisher ? `<p class="text-sm text-gray-600"><strong>Publisher:</strong> ${comic.publisher}</p>` : ''}
                    ${comic.artist ? `<p class="text-sm text-gray-600"><strong>Cover Artist:</strong> ${comic.artist}</p>` : ''}
                    ${comic.releaseDate ? `<p class="text-sm text-gray-600"><strong>Released:</strong> ${comic.releaseDate}</p>` : ''}
                    ${costDisplay ? `<p class="text-sm text-gray-600"><strong>Cost:</strong> ${costDisplay}</p>` : ''}
                    <div class="mt-4 pt-4 border-t border-gray-200 flex justify-between items-center space-x-2">
                         <button id="toggle-read-btn" class="flex-1 inline-flex justify-center items-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white ${readButtonColor} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            <span class="lucide ${readButtonIcon} mr-2"></span> ${readButtonText}
                        </button>
                         <button id="view-series-btn" class="flex-1 inline-flex justify-center items-center py-2 px-4 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                            View Series
                        </button>
                    </div>
                `;
                detailContentElement.querySelector('#toggle-read-btn').addEventListener('click', handleToggleReadClick);
                detailContentElement.querySelector('#view-series-btn').addEventListener('click', handleViewSeriesClick);
            }, 50);
        }

        function showSeriesView(title, originatingComicId) {
            state.currentDetailComicId = originatingComicId;
            const { title: seriesTitleElement, list: seriesListElement, backBtnInfo } = appElements.series;
            seriesTitleElement.textContent = title;
            seriesListElement.innerHTML = '<div class="loader"></div>';
            showView('series');
            const originatingComic = state.comics.find(c => c.id === originatingComicId);
            backBtnInfo.textContent = `Back to ${title} #${originatingComic?.issue || 'Details'}`;
            console.log(`Showing series view for title: "${title}"`);

            setTimeout(() => {
                seriesListElement.innerHTML = '';
                try {
                    const lowerTitle = title.toLowerCase();
                    let issuesToShow = []; let source = 'collection';
                    const mockIssuesKey = Object.keys(mockSeriesDb).find(key => key.toLowerCase() === lowerTitle);
                    if (mockIssuesKey) { issuesToShow = mockSeriesDb[mockIssuesKey]; source = 'mockDB'; console.log(`Using mockDB for "${title}". Issues:`, issuesToShow); }
                    else {
                        const owned = state.comics.filter(c => c.title.toLowerCase() === lowerTitle).map(c => c.issue);
                        const wanted = state.wantsList.filter(w => w.title.toLowerCase() === lowerTitle).map(w => w.issue);
                        issuesToShow = [...new Set([...owned, ...wanted])].sort((a, b) => {
                             const issueA = parseFloat(a) || a; const issueB = parseFloat(b) || b;
                             if (!isNaN(issueA) && !isNaN(issueB)) return issueA - issueB; if (!isNaN(issueA)) return -1; if (!isNaN(issueB)) return 1; return a.localeCompare(b);
                         });
                        console.log(`Using owned/wanted issues for "${title}". Issues:`, issuesToShow);
                    }

                    if (issuesToShow.length === 0 && source !== 'mockDB') {
                         seriesListElement.innerHTML = '<p class="text-gray-500 text-center p-4">No other issues found for this series in your collection or wishlist.</p>';
                    } else {
                         issuesToShow.forEach(issueNumStr => {
                             const issueNum = String(issueNumStr);
                             const ownedComic = state.comics.find(c => c.title.toLowerCase() === lowerTitle && String(c.issue) === issueNum);
                             const isWanted = !ownedComic && state.wantsList.some(w => w.title.toLowerCase() === lowerTitle && String(w.issue) === issueNum);
                             const isOriginating = ownedComic?.id === originatingComicId;
                             const issueDiv = document.createElement('div');
                             // Adjusted text/icon colors
                             issueDiv.className = `flex justify-between items-center p-3 bg-white rounded shadow-sm text-gray-800 ${ownedComic ? 'hover:bg-gray-50 cursor-pointer' : ''} ${isOriginating ? 'ring-2 ring-indigo-400' : ''}`;
                             if (ownedComic) { issueDiv.dataset.comicId = ownedComic.id; issueDiv.setAttribute('role', 'button'); issueDiv.setAttribute('tabindex', '0'); issueDiv.setAttribute('aria-label', `View details for issue ${issueNum}`); }
                             let statusHtml = '';
                             if (ownedComic) {
                                 statusHtml = `${ownedComic.status.read ? '<span class="lucide icon-eye text-green-500 text-sm" title="Read"></span>' : '<span class="lucide icon-eye-off text-gray-400 text-sm" title="Unread"></span>'} <span class="text-xs font-medium text-indigo-600">Owned</span>`;
                             } else if (isWanted) {
                                 statusHtml = `<button data-title="${title}" data-issue="${issueNum}" aria-label="Remove issue ${issueNum} from Wishlist" class="toggle-want-btn text-red-500 hover:text-red-700 focus:outline-none focus:ring-1 focus:ring-red-500 rounded-full p-1"><span class="lucide icon-heart icon-sm" title="On Wishlist"></span></button>`;
                             } else {
                                 statusHtml = `<button data-title="${title}" data-issue="${issueNum}" aria-label="Add issue ${issueNum} to Wishlist" class="toggle-want-btn text-gray-400 hover:text-green-600 focus:outline-none focus:ring-1 focus:ring-green-500 rounded-full p-1"><span class="lucide icon-heart icon-sm" title="Add to Wishlist"></span></button>`;
                             }
                             issueDiv.innerHTML = `<span>Issue #${issueNum}</span> <div class="flex items-center space-x-2">${statusHtml}</div>`;
                             seriesListElement.appendChild(issueDiv);
                         });
                         seriesListElement.addEventListener('click', handleSeriesItemInteraction);
                         seriesListElement.addEventListener('keydown', handleSeriesItemInteraction);
                    }
                } catch (error) { console.error("Error rendering series view:", error); seriesListElement.innerHTML = '<p class="text-red-500 text-center p-4">Error loading series information.</p>'; }
            }, 200);
        }

        // ========================================================================
        // Event Handlers & Action Functions
        // ========================================================================

         function handleComicItemClick(comicId) { console.log("Comic item clicked/activated:", comicId); showComicDetail(comicId); }

         function handleSeriesItemInteraction(e) {
             if (e.type === 'keydown' && e.key !== 'Enter' && e.key !== ' ') return;
             const target = e.target;
             const wantButton = target.closest('.toggle-want-btn');
             const ownedItem = target.closest('[data-comic-id]');
             if (wantButton) {
                 e.preventDefault(); const wantTitle = wantButton.dataset.title; const wantIssue = wantButton.dataset.issue;
                 console.log(`Want button clicked for ${wantTitle} #${wantIssue}`);
                 toggleWantStatus(wantTitle, wantIssue); showSeriesView(wantTitle, state.currentDetailComicId);
             } else if (ownedItem && (e.type === 'click' || e.type === 'keydown')) {
                  e.preventDefault(); const comicId = ownedItem.dataset.comicId;
                  console.log(`Owned series item activated: ${comicId}`); showComicDetail(comicId);
             }
         }

        function handleComicFormSubmit(e) {
            e.preventDefault(); console.log('Comic form submission initiated.');
            const { form, idInput, titleInput, issueInput, dateInput, costInput, artistInput, publisherInput, coverDataInput } = appElements.addForm;
            let isValid = true;
            form.querySelectorAll('[data-validation-for]').forEach(el => el.classList.add('hidden'));
            const title = titleInput.value.trim(); const issue = issueInput.value.trim(); const cost = costInput.value.trim();
            if (!title) { isValid = false; form.querySelector('[data-validation-for="comic-title"]').classList.remove('hidden'); }
            if (!issue) { isValid = false; form.querySelector('[data-validation-for="comic-issue"]').classList.remove('hidden'); }
            if (cost && (isNaN(parseFloat(cost)) || parseFloat(cost) < 0)) { isValid = false; form.querySelector('[data-validation-for="comic-cost"]').classList.remove('hidden'); }
            const coverData = coverDataInput.value; const imageSizeErrorElement = form.querySelector('[data-validation-for="comic-cover-upload"]');
            if (coverData && coverData.length * 0.75 > MAX_IMAGE_SIZE_BYTES) { isValid = false; imageSizeErrorElement.textContent = "Image file is too large (max 2MB)."; imageSizeErrorElement.classList.remove('hidden'); showMessage("Cover image is too large (max 2MB).", 'error', 5000); }
            if (!isValid) { console.warn("Form validation failed."); showMessage("Please correct the errors in the form.", 'error'); return; }

            setSaveButtonState(false); // Disable button
            const id = idInput.value; const releaseDate = dateInput.value; const artist = artistInput.value.trim(); const publisher = publisherInput.value.trim();
            let finalCoverImage = coverData;
             if (id && !finalCoverImage) { const existingComic = state.comics.find(c => c.id === id); finalCoverImage = existingComic ? existingComic.coverImage : null; }
            console.log('Form data validated:', { id, title, issue, releaseDate, cost, artist, publisher, coverImage: finalCoverImage ? 'Image data present' : 'No image data' });

            setTimeout(() => {
                try {
                    if (id) {
                        const index = state.comics.findIndex(c => c.id === id);
                        if (index > -1) { state.comics[index] = { ...state.comics[index], title, issue, releaseDate, cost, artist, publisher, coverImage: finalCoverImage }; console.log('Updated comic object:', state.comics[index]); showMessage("Comic updated successfully!", 'success'); }
                        else { console.error("Failed to find comic with ID for editing:", id); throw new Error("Could not find the comic to update."); }
                    } else {
                        const newComic = { id: generateComicId(), title, issue, releaseDate, cost, artist, publisher, coverImage: finalCoverImage, status: { owned: true, read: false, wants: false } };
                        console.log('New comic object:', newComic); state.comics.push(newComic);
                        const wasWanted = removeWantIfExists(title, issue);
                        showMessage(wasWanted ? "Comic added and removed from wishlist!" : "Comic added successfully!", 'success');
                    }
                    saveData(); resetForm(); renderCollection();
                    console.log('Save successful, navigating back to collection.'); showView('collection');
                } catch (error) { console.error("Error during form submission processing:", error); showMessage(`Error saving comic: ${error.message || 'Unknown error'}`, 'error', 5000); setSaveButtonState(true); }
            }, 300);
        }

        function handleCoverImageChange(event) {
            const file = event.target.files[0]; const { coverPreview, coverDataInput } = appElements.addForm;
            const errorElement = appElements.addForm.form.querySelector('[data-validation-for="comic-cover-upload"]');
            errorElement.classList.add('hidden'); console.log("File selected:", file ? file.name : "No file");
            if (file && file.type.startsWith('image/')) {
                if (file.size > MAX_IMAGE_SIZE_BYTES) { showMessage("Image file is too large (max 2MB).", 'error', 4000); errorElement.textContent = "Image file is too large (max 2MB)."; errorElement.classList.remove('hidden'); resetCoverPreview(); return; }
                const reader = new FileReader();
                reader.onload = (e) => { console.log("FileReader loaded image data."); coverPreview.src = e.target.result; coverPreview.classList.remove('hidden'); coverDataInput.value = e.target.result; }
                reader.onerror = (e) => { console.error("FileReader error:", e); showMessage("Error reading image file.", 'error', 4000); resetCoverPreview(); }
                reader.readAsDataURL(file);
            } else if (file) { showMessage("Please select a valid image file (JPEG, PNG, GIF, WebP).", 'error', 4000); resetCoverPreview(); }
            else { resetCoverPreview(); }
        }

        function resetCoverPreview() {
             const { coverPreview, coverDataInput, coverUpload } = appElements.addForm;
             coverPreview.classList.add('hidden'); coverPreview.src = '#'; coverDataInput.value = ''; coverUpload.value = ''; console.log("Cover preview reset.");
             appElements.addForm.form.querySelector('[data-validation-for="comic-cover-upload"]').classList.add('hidden');
        }

        function resetForm() {
            const { form, idInput, title: addEditTitleElement } = appElements.addForm;
            form.reset(); idInput.value = ''; resetCoverPreview(); addEditTitleElement.textContent = 'Add New Comic';
            form.querySelectorAll('[data-validation-for]').forEach(el => el.classList.add('hidden'));
            setSaveButtonState(true); console.log("Add/Edit form reset.");
        }

        function handleNavButtonClick(event) {
            const button = event.currentTarget; const targetView = button.getAttribute('data-view');
            if (targetView) { if (targetView === 'add' || state.currentView === 'add') { resetForm(); } showView(targetView); }
        }

        function handleScanButtonClick() {
            console.log("Scan Comic button clicked (simulation)."); resetForm();
            appElements.addForm.titleInput.value = "Saga"; appElements.addForm.issueInput.value = "1"; appElements.addForm.dateInput.value = "2012-03-14";
            appElements.addForm.artistInput.value = "Fiona Staples"; appElements.addForm.publisherInput.value = "Image Comics";
            appElements.addForm.title.textContent = 'Add Scanned Comic (Confirm Details)'; showView('add');
            showMessage("Simulated Scan: Please confirm details and add cover.", 'info', 4000);
        }

        function handleBackButtonClick(event) {
             const buttonId = event.currentTarget.id; console.log(`Back button clicked: ${buttonId}`);
             const currentFilter = appElements.collection.searchInput.value.trim();
             switch (buttonId) {
                 case 'back-to-collection-btn': resetForm(); showView('collection'); renderCollection(currentFilter); break;
                 case 'back-to-collection-detail-btn': showView('collection'); renderCollection(currentFilter); break;
                 case 'back-to-detail-btn':
                     if (state.currentDetailComicId) { showComicDetail(state.currentDetailComicId); }
                     else { console.warn("currentDetailComicId not set, falling back to collection."); showView('collection'); renderCollection(); } break;
             }
        }

        function handleDeleteButtonClick() {
            if (!state.currentDetailComicId) { console.warn("Delete button clicked but no currentDetailComicId set."); return; }
            const comicToDelete = state.comics.find(c => c.id === state.currentDetailComicId);
            if (!comicToDelete) { showMessage("Error: Comic to delete not found.", 'error'); return; }
            if (confirm(`Are you sure you want to delete ${comicToDelete.title} #${comicToDelete.issue}? This cannot be undone.`)) {
                console.log("Deleting comic with ID:", state.currentDetailComicId);
                state.comics = state.comics.filter(c => c.id !== state.currentDetailComicId); saveData();
                showMessage("Comic deleted.", 'success'); renderCollection(); showView('collection'); state.currentDetailComicId = null;
            } else { console.log("Deletion cancelled by user."); }
        }

        function handleEditButtonClick() {
             if (!state.currentDetailComicId) { console.warn("Edit button clicked but no currentDetailComicId set."); return; }
             const comic = state.comics.find(c => c.id === state.currentDetailComicId);
             if (comic) {
                 console.log("Editing comic:", comic); resetForm();
                 appElements.addForm.title.textContent = 'Edit Comic'; appElements.addForm.idInput.value = comic.id;
                 appElements.addForm.titleInput.value = comic.title; appElements.addForm.issueInput.value = comic.issue;
                 appElements.addForm.dateInput.value = comic.releaseDate || ''; appElements.addForm.costInput.value = comic.cost || '';
                 appElements.addForm.artistInput.value = comic.artist || ''; appElements.addForm.publisherInput.value = comic.publisher || '';
                 appElements.addForm.coverDataInput.value = comic.coverImage || '';
                 if (comic.coverImage) { appElements.addForm.coverPreview.src = comic.coverImage; appElements.addForm.coverPreview.classList.remove('hidden'); }
                 else { resetCoverPreview(); }
                 showView('add');
             } else { console.error("Edit button clicked, but comic not found for ID:", state.currentDetailComicId); showMessage("Error: Could not find comic to edit.", 'error'); }
        }

        let searchTimeout;
        function handleSearchInput(e) {
             clearTimeout(searchTimeout); const filterValue = e.target.value.trim();
             searchTimeout = setTimeout(() => { console.log("Search triggered with:", filterValue); renderCollection(filterValue); }, 300);
        }

        function handleToggleViewClick() {
             const newLayout = state.currentLayout === 'grid' ? 'list' : 'grid';
             console.log("Toggling layout view to:", newLayout); state.currentLayout = newLayout;
             toggleCollectionViewLayoutUI(newLayout); saveData();
        }

        function handleToggleReadClick() {
            if (!state.currentDetailComicId) return;
            const index = state.comics.findIndex(c => c.id === state.currentDetailComicId);
            if (index > -1) {
                state.comics[index].status.read = !state.comics[index].status.read;
                console.log(`Toggled read status for ${state.comics[index].title} #${state.comics[index].issue} to ${state.comics[index].status.read}`);
                saveData(); showComicDetail(state.currentDetailComicId);
                showMessage(`Marked as ${state.comics[index].status.read ? 'Read' : 'Unread'}.`, 'info');
            } else { console.error("Could not find comic to toggle read status for ID:", state.currentDetailComicId); }
        }

        function handleViewSeriesClick() {
             if (!state.currentDetailComicId) return;
             const comic = state.comics.find(c => c.id === state.currentDetailComicId);
             if (comic) { showSeriesView(comic.title, comic.id); }
             else { console.error("Could not find comic to view series for ID:", state.currentDetailComicId); }
        }

        function toggleWantStatus(title, issue) {
             const lowerTitle = title.toLowerCase(); const issueStr = String(issue);
             const wantIndex = state.wantsList.findIndex(w => w.title.toLowerCase() === lowerTitle && String(w.issue) === issueStr);
             if (wantIndex > -1) {
                 state.wantsList.splice(wantIndex, 1); console.log(`Removed ${title} #${issueStr} from wants list.`);
                 showMessage(`Removed ${title} #${issueStr} from wishlist.`, 'info');
             } else {
                 const isOwned = state.comics.some(c => c.title.toLowerCase() === lowerTitle && String(c.issue) === issueStr);
                 if (isOwned) { console.warn(`Attempted to add owned comic ${title} #${issueStr} to wants list.`); showMessage(`You already own ${title} #${issueStr}.`, 'info'); return; }
                 state.wantsList.push({ title, issue: issueStr }); console.log(`Added ${title} #${issueStr} to wants list.`);
                 showMessage(`Added ${title} #${issueStr} to wishlist.`, 'success');
             }
             saveData();
         }

         function removeWantIfExists(title, issue) {
             const lowerTitle = title.toLowerCase(); const issueStr = String(issue);
             const wantIndex = state.wantsList.findIndex(w => w.title.toLowerCase() === lowerTitle && String(w.issue) === issueStr);
             if (wantIndex > -1) { state.wantsList.splice(wantIndex, 1); console.log(`Removed ${title} #${issueStr} from wants list automatically.`); return true; }
             return false;
         }

        // ========================================================================
        // Initialization
        // ========================================================================

        function initializeEventListeners() {
            appElements.addForm.form.addEventListener('submit', handleComicFormSubmit);
            appElements.addForm.coverUpload.addEventListener('change', handleCoverImageChange);
            appElements.navigation.navButtons.forEach(button => button.addEventListener('click', handleNavButtonClick));
            appElements.navigation.scanBtn.addEventListener('click', handleScanButtonClick);
            appElements.navigation.backToAddBtn.addEventListener('click', handleBackButtonClick);
            appElements.detail.backBtn.addEventListener('click', handleBackButtonClick);
            appElements.series.backBtn.addEventListener('click', handleBackButtonClick);
            appElements.detail.editBtn.addEventListener('click', handleEditButtonClick);
            appElements.detail.deleteBtn.addEventListener('click', handleDeleteButtonClick);
            appElements.collection.searchInput.addEventListener('input', handleSearchInput);
            appElements.collection.toggleViewBtn.addEventListener('click', handleToggleViewClick);
        }

        function initializeApp() {
            console.log("Initializing ComicTrackr App...");
            loadData(); initializeEventListeners(); showView('collection'); renderCollection();
            console.log("ComicTrackr App Initialized.");
        }

        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>
</body>
</html>
